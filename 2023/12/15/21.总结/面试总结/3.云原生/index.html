<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">



  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.4.2">


  <link rel="mask-icon" href="/images/favicon.jpg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","width":280,"display":"always","offset":25,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="kubenetes架构与运维1.kubernetes 的组成kubernetes 架构主要包含两个组件：  主节点(Master) 工作节点(Node)  主节点有许多内置组件：  kube-apiserver:这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服 务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式">
<meta property="og:type" content="article">
<meta property="og:title" content="云原生面试整理">
<meta property="og:url" content="http://blog.kyleliu.cn/2023/12/15/21.%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/3.%E4%BA%91%E5%8E%9F%E7%94%9F/index.html">
<meta property="og:site_name" content="刘小恺(Kyle)的云笔记">
<meta property="og:description" content="kubenetes架构与运维1.kubernetes 的组成kubernetes 架构主要包含两个组件：  主节点(Master) 工作节点(Node)  主节点有许多内置组件：  kube-apiserver:这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服 务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1695128967704.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1695131651452.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1695131454182.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1695132723654.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1695131950421.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1697550229461.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1697551524292.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1695306849887.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1700528361306.png">
<meta property="og:image" content="http://blog.kyleliu.cn/img/1700616123027.png">
<meta property="article:published_time" content="2023-12-15T04:00:00.000Z">
<meta property="article:modified_time" content="2024-02-08T12:23:49.938Z">
<meta property="article:author" content="刘小恺(Kyle)">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.kyleliu.cn/img/1695128967704.png">






  <link rel="canonical" href="http://blog.kyleliu.cn/2023/12/15/21.总结/面试总结/3.云原生/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>云原生面试整理 | 刘小恺(Kyle)的云笔记</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?61af49e7933cbd35801eb5e4ca789a8d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">刘小恺(Kyle)的云笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">吃喝玩乐、好吃懒做、醉生梦死、不劳而获</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.kyleliu.cn/2023/12/15/21.%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/3.%E4%BA%91%E5%8E%9F%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘小恺(Kyle)">
      <meta itemprop="description" content="吃喝玩乐、好吃懒做、醉生梦死、不劳而获">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘小恺(Kyle)的云笔记">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">云原生面试整理
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2023-12-15 12:00:00" itemprop="dateCreated datePublished" datetime="2023-12-15T12:00:00+08:00">2023-12-15</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">面试总结</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2023/12/15/21.%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/3.%E4%BA%91%E5%8E%9F%E7%94%9F/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2023/12/15/21.%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/3.%E4%BA%91%E5%8E%9F%E7%94%9F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="kubenetes架构与运维"><a href="#kubenetes架构与运维" class="headerlink" title="kubenetes架构与运维"></a>kubenetes架构与运维</h2><h3 id="1-kubernetes-的组成"><a href="#1-kubernetes-的组成" class="headerlink" title="1.kubernetes 的组成"></a>1.kubernetes 的组成</h3><p>kubernetes 架构主要包含两个组件：</p>
<ul>
<li>主节点(Master)</li>
<li>工作节点(Node)</li>
</ul>
<p><strong>主节点有许多内置组件：</strong></p>
<ul>
<li>kube-apiserver:这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服 务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式的清单文件（manifest  files）。 </li>
<li>kube-controller-manager:被称为“kube-controller manager”，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点（endpoint）控制器以及服务账户等。 </li>
<li>kube-scheduler:调度器会监控新建的 pods（一组或一个容器）并将其分配给节点。</li>
<li>data-store(etcd):Kubernetes 使用“etcd”。这是一个强大的、稳定的、高可用的键值存储，被 Kubernetes 用于长久储存所有的 API 对象。 </li>
<li>kube-dns：它负责将服务名称解析为相应的IP地址，并确保服务之间可以通过名称进行通信。</li>
</ul>
<p><strong>工作节点内置组件:</strong></p>
<ul>
<li>kubelet:负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态报告给主节点的渠道，通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器。它 还会定期执行被请求的容器的健康探测程序。 </li>
<li>kube-proxy:它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的 pods 进行负载平衡。</li>
</ul>
<h3 id="2-简述kubenetes-的基础概念"><a href="#2-简述kubenetes-的基础概念" class="headerlink" title="2.简述kubenetes 的基础概念"></a>2.简述kubenetes 的基础概念</h3><p><strong>Master控制组件</strong></p>
<ul>
<li>Kubenetes API Server： 作为K8s系统的入口，其封装了核心对象的增删改查操作， 集群内各个功能模块之间数据交互和通信的中心枢纽</li>
<li>Kubenetes Scheduler： 为新建立的Pod进行节点选择负责集群的资源调度</li>
<li>Kubenetes Controller： 负责执行各种控制器，目前已经提供了很多控制器来保证Kubenetes的正常运行；</li>
<li>Replication Controller： 管理维护 Replication Controller，管理Replication Controller 和Pod，保证Replication Controller 定义的副本数量与实际运行的Pod数量一致；</li>
<li>Node Controller： 管理维护Node， 定期检查Node的健康状态，标识出失效/未失效的Node节点</li>
<li>Namespace Controller： 管理维护Namespace，定期清理无效的Namespace，包括Namespace下的API对象，比如Pod，Service 等</li>
<li>Service Controller： 管理维护Serivice，负责负载均衡以及服务代理。</li>
<li>Endpoint Controller： 管理维护Endpoints，关联Service 和Pod，创建Endpoints为Service的后端， 当Pod发生变化时，实时更新Endpoints。</li>
<li>Service Account Controller： 管理维护Service Account，为每个Namespace创建默认的Serive Account，同时为Service Account 创建Service Account Sercret。</li>
<li>Daemonset Controller： 管理维护Daemon Set，负责创建Daemon Pod， 保证指定的Node上正常的运行Daemon Pod。</li>
<li>Deployment Controller：管理维护Deployment，关联Deployment和Replication Controller，保证运行指定数量的Pod。当Deployment更新时，控制实现Replication Controller 和Pod 的更新。</li>
<li>Job Controller： 管理和维护Job， 为Job创建一次性任务Pod， 保证完成Job指定完成的任务数目。</li>
<li>Pod Autoscaler Controller：实现Pod的自动伸缩，定时获取监控数据，进行策略匹配， 当满足条件时执行Pod的伸缩动作。</li>
</ul>
<h3 id="3-Worker-节点加入集群的过程"><a href="#3-Worker-节点加入集群的过程" class="headerlink" title="3.Worker 节点加入集群的过程"></a>3.Worker 节点加入集群的过程</h3><p>通常需要对 Worker 节点进行扩容，从而将应用系统进行水平扩展。主要过程如下：</p>
<ol>
<li>在该 Node 上安装 Docker、kubelet 和 kube-proxy 服务；</li>
<li>然后配置 kubelet 和 kubeproxy 的启动参数，将 Master URL 指定为当前Kubernetes 集群 Master 的地址，最后启动这些服务；</li>
<li>通过 kubelet 默认的自动注册机制，新的 Worker 将会自动加入现有的Kubernetes 集群中；</li>
<li>Kubernetes Master 在接受了新 Worker 的注册之后，会自动将其纳入当前集群的调度范围。</li>
</ol>
<h3 id="4-如何使用-EFK-统一管理k8s日志"><a href="#4-如何使用-EFK-统一管理k8s日志" class="headerlink" title="4.如何使用 EFK 统一管理k8s日志"></a>4.如何使用 EFK 统一管理k8s日志</h3><p>在 Kubernetes 集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用 EFK 实现。</p>
<p>EFK 是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下：</p>
<ul>
<li>Elasticsearch：是一个搜索引擎，负责存储日志并提供查询接口；</li>
<li>Fluentd：负责从 Kubernetes 搜集日志，每个 node 节点上面的 fluentd 监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给 Elasticsearch；</li>
<li>Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。</li>
</ul>
<p>通过在每台 node 上部署一个以 DaemonSet 方式运行的 fluentd 来收集每台 node 上的日志。Fluentd 将docker 日志目录/var/lib/docker/containers 和/var/log 目录挂载到 Pod 中，然后 Pod 会在 node 节点的/var/log/pods 目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到/var/lib/docker/contianers 目录下的容器日志输出。</p>
<h3 id="5-K8s如何优雅的关机维护节点"><a href="#5-K8s如何优雅的关机维护节点" class="headerlink" title="5.K8s如何优雅的关机维护节点"></a>5.K8s如何优雅的关机维护节点</h3><p>由于 Kubernetes 节点运行大量 Pod，因此在进行关机维护之前，建议先使用kubectl drain 将该节点的 Pod 进行驱逐，然后进行关机维护。</p>
<h2 id="kubenetes-控制平面"><a href="#kubenetes-控制平面" class="headerlink" title="kubenetes 控制平面"></a>kubenetes 控制平面</h2><h3 id="1-etcd-介绍和适应的场景"><a href="#1-etcd-介绍和适应的场景" class="headerlink" title="1. etcd 介绍和适应的场景"></a>1. etcd 介绍和适应的场景</h3><p>Etcd是CoreOS<strong>基于Raft</strong>开发的<strong>分布式key-value存储</strong>， etcd基于其优秀的特点， 可广泛的应用于以下场景</p>
<ul>
<li>基本的key-value存储 </li>
<li>监听机制 </li>
<li>key的过期及续约机制，用于监控和服务发现 </li>
<li>原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举</li>
</ul>
<h3 id="2-etcd-store-的实现"><a href="#2-etcd-store-的实现" class="headerlink" title="2.etcd store 的实现"></a>2.etcd store 的实现</h3><p>etcd v3 store 分为两部分: </p>
<ul>
<li>一部分是内存中的索引，kvindex，是基于Google开源的一个Golang的btree实现的</li>
<li>另外一部分是后端存储。按照它的设计，backend可以对接多种存储，当前使用的boltdb。是一个单机的支持事务的kv存储，etcd 的事务是基于boltdb的事务实现的。</li>
</ul>
<p>etcd 在每次修改 key 时会生成一个全局递增的版本号（revision）。</p>
<ul>
<li>然后通过数据结构 B-tree 保存 key 与版本号之间的关系；</li>
<li>再以版本号作为 boltdb key，以用户的 key-value 等信息作为 boltdb value，保存到 boltdb。也就是说 etcd 会在boltdb中把每个版本都保存下，从而实现了多版本机制。</li>
</ul>
<p><strong>reversion的结构</strong></p>
<p>reversion主要由两部分组成，第一部分main rev，每次事务进行加一，第二部分sub rev，同一个事务中的每次操作加一。</p>
<p>etcd 提供了命令和设置选项来控制compact来进行版本压缩，同时支持put操作的参数来精确控制某个key的历史版本数。</p>
<p>内存kvindex保存的就是key和reversion之间的映射关系，用来加速查询。</p>
<p>k8s更新应用时，K8S都会记录当前的版本号，即为revision，当升级出现问题时，可通过回滚到某个特定的revision，默认配置下，K8S只会保留最近的几个revision，可以通过Deployment配置文件中的spec.revisionHistoryLimit属性增加revision数量，默认是10。</p>
<h3 id="3-K8s部署高可用的etcd经验"><a href="#3-K8s部署高可用的etcd经验" class="headerlink" title="3.K8s部署高可用的etcd经验"></a>3.K8s部署高可用的etcd经验</h3><ul>
<li>合适的peer数量：通常为5个，可以允许2个节点挂掉不影响正常运行</li>
<li>部署方式的优化：<ul>
<li>apiserver和etcd可以部署在同一节点</li>
<li>部署的方式尽量同地域部署</li>
</ul>
</li>
<li>负载均衡：可以将etcd事件分离的多个不同的etcd集群， 对etcd集群进行规划和流量负载均衡</li>
<li>合理的日志文件大小： 无论是数据创建还是修改， etcd都会保存raft日志，为了有效降低日志文件大小，etcd会以固定周期创建快照保存系统的当前状态，并移除旧日志文件。另外当修改次数累积到一定的数量（默认是10000，通过参数“–snapshot-count”指定），etcd也会创建快照文件。</li>
<li>自动压缩历史版本：etcd会为每个键都保存了历史版本。为了避免出现性能问题或存储空间消耗完导致写不进去的问题，这些历史版本需要进行周期性地压缩。压缩历史版本就是丢弃该键给定版本之前的所有信息，节省出来的空间可以用于后续的写操作。etcd支持自动压缩历史版本。在启动参数中指定参数“–auto-compaction”，其值以小时为单位。也就是etcd会自动压缩该值设置的时间窗口之前的历史版本。</li>
<li>定期消除碎片化： 压缩历史版本，相当于离散地抹去etcd存储空间某些数据，etcd存储空间中将会出现碎片。这些碎片无法被后台存储使用，却仍占据节点的存储空间。因此定期消除存储碎片，将释放碎片化的存储空间，重新调整整个存储空间。 可以使用命令etcdctl defrag</li>
<li>备份方案<ul>
<li>etcd备份： 通过  etcdctl snapshot save， 备份的时间间隔需要考虑， 时间过长， 会导致数据丢失过多， 时间间隔太短， 会造成etcd频繁对数据上锁， 会对etcd造成影响</li>
<li>如何确保备份的时效性， 同时防止磁盘爆掉： 通过 snapshot + 备份wal log ， 来用snapshot进行恢复， wallog进行回放。</li>
</ul>
</li>
</ul>
<h3 id="4-apiserver介绍"><a href="#4-apiserver介绍" class="headerlink" title="4.apiserver介绍"></a>4.apiserver介绍</h3><p>Kube-APIServer 是 Kubernetes 最重要的核心组件之一，主要提供以下功能： </p>
<ul>
<li>提供集群管理的 REST API 接口，包括: </li>
<li>认证 Authentication； </li>
<li>鉴权 Authorization； </li>
<li>准入 Admission（Mutating &amp; Valiating）；<ul>
<li>mutating： 可以修改对象的值</li>
<li>Validating： 不可以对对象的值进行修改</li>
</ul>
</li>
<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 APIServer 查询或 修改数据，只有 APIServer 才直接操作 etcd）。 </li>
<li>APIServer 提供 etcd 数据缓存以减少集群对 etcd 的访问。</li>
</ul>
<p><img src="/img/1695128967704.png" alt="1695128967704"></p>
<h3 id="5-apiserver认证"><a href="#5-apiserver认证" class="headerlink" title="5.apiserver认证"></a>5.apiserver认证</h3><p>开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。</p>
<p>如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。</p>
<p><strong>认证插件</strong></p>
<ul>
<li>X509证书</li>
<li>静态Token文件</li>
<li>引导Token</li>
<li>静态密码文件</li>
<li>ServiceAccount</li>
<li>OpenID</li>
<li>Webhook 令牌身份认证</li>
<li>匿名请求</li>
</ul>
<h3 id="6-apiserver鉴权介绍"><a href="#6-apiserver鉴权介绍" class="headerlink" title="6.apiserver鉴权介绍"></a>6.apiserver鉴权介绍</h3><p>授权主要是用于对集群资源的访问控制，通过检查请求包含的相关属性值，与相对应的访问策略相比较，API请求必须满足某些策略才能被处理。跟认证类似，Kubernetes也支持多种授权机制，并支持同时开启多个授权插件（只要有一个验证通过即可）。如果授权成功，则用户的请求会发送到准入控制模块做进一步的请求验证；对于授权失败的请求则返回HTTP 403。</p>
<p>Kubernetes授权仅处理以下的请求属性：</p>
<ul>
<li>user, group, extra</li>
<li>API、请求方法（如get、post、update、patch和delete）和请求路径（如/api）</li>
<li>请求资源和子资源</li>
<li>Namespace</li>
<li>API Group</li>
</ul>
<p>目前，Kubernetes支持以下授权插件：</p>
<ul>
<li>ABAC： 基于配置的权限控制</li>
<li>RBAC： 基于角色的权限控制</li>
<li>Webhook： 基于webhook服务的外部权限控制</li>
<li>Node：控制不同Node节点的权限范围</li>
</ul>
<h3 id="7-Kubenetes-RBAC-vs-ABAC"><a href="#7-Kubenetes-RBAC-vs-ABAC" class="headerlink" title="7.Kubenetes   RBAC vs ABAC"></a>7.Kubenetes   RBAC vs ABAC</h3><p>ABAC（Attribute Based Access Control）本来是不错的概念，但是在Kubernetes 中的实现比较难于管理和理解，而且需要对Master 所在节点的SSH 和文件系统权限，要使得对授权的变更成功生效，还需要重新启动API Server。</p>
<p>而RBAC 的授权策略可以利用kubectl 或者Kubernetes API 直接进行配置。RBAC 可以授权给用户，让用户有权进行授权管理，这样就可以无需接触节点，直接进行授权管理。RBAC 在Kubernetes中被映射为API 资源和操作。</p>
<h3 id="8-Kubernetes-的准入机制"><a href="#8-Kubernetes-的准入机制" class="headerlink" title="8.Kubernetes 的准入机制"></a>8.Kubernetes 的准入机制</h3><p>准入控制（Admission Control）在授权后对请求做进一步的验证或添加默认参数。不同于授权和认证只关心请求的用户和操作，准入控制还处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等有效，而对读操作无效。</p>
<p>准入控制支持同时开启多个插件，它们依次调用，只有全部插件都通过的请求才可以放过进入系统，并且可以为对象增加的自定义属性，或者创建新的关联对象登操作。</p>
<p><strong>常用组件（控制代码）如下：</strong></p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，多用于测试环境。</li>
<li>ServiceAccount：它将 serviceAccounts 实现了自动化，它会辅助serviceAccount 做一些事情，比如如果pod 没有 serviceAccount 属性，它会自动添加一个 default，并确保 pod 的 serviceAccount 始终存在。</li>
<li>LimitRanger：观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在 namespace 中LimitRange 对象中。</li>
<li>NamespaceExists：观察所有的请求，如果请求尝试创建一个不存在的namespace，则这个请求被拒绝。</li>
</ul>
<p><strong>自定义mutating插件举例：为资源增加自定义属性</strong></p>
<ul>
<li>作为多租户集群方案中的一环，我们需要在namespace的准入控制中，获取用户信息，并将用户信息更新到namespace的annotation</li>
<li>只有当namespace中有有效用户信息时，我们才可以在namespace创建时，自动绑定用户权限，namespace才可用。</li>
</ul>
<h3 id="9-Kubernetes-如何保证集群的安全性"><a href="#9-Kubernetes-如何保证集群的安全性" class="headerlink" title="9.Kubernetes 如何保证集群的安全性"></a>9.Kubernetes 如何保证集群的安全性</h3><p>Kubernetes 通过一系列机制来实现集群的安全控制，主要有如下不同的维度：</p>
<ul>
<li>基础设施方面：保证容器与其所在宿主机的隔离；</li>
<li>权限方面：<ul>
<li>最小权限原则：合理限制所有组件的权限，确保组件只执行它被授权的行为， 通过限制单个组件的能力来限制它的权限范围。</li>
<li>用户权限：划分普通用户和管理员的角色。</li>
</ul>
</li>
<li>集群方面：<ul>
<li>API Server 的认证授权：Kubernetes 集群中所有资源的访问和变更都是通过Kubernetes API Server 来实现的，因此需要建议采用更安全的 HTTPS 或Token 来识别和认证客户端身份（Authentication），以及随后访问权限的授权（Authorization）环节。</li>
<li>API Server 的授权管理：通过授权策略来决定一个 API 调用是否合法。对合法用户进行授权并且随后在用户访问时进行鉴权，建议采用更安全的 RBAC 方式来提升集群安全授权。</li>
<li>敏感数据引入 Secret 机制：对于集群敏感数据建议使用 Secret 方式进行保护。</li>
<li>AdmissionControl（准入机制）：对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。</li>
</ul>
</li>
</ul>
<h3 id="10-K8s各模块如何与-API-Server-通信"><a href="#10-K8s各模块如何与-API-Server-通信" class="headerlink" title="10.K8s各模块如何与 API Server 通信"></a>10.K8s各模块如何与 API Server 通信</h3><p>Kubernetes API Server 作为集群的核心，负责集群各功能模块之间的通信。</p>
<p>集群内的各个功能模块通过 API Server 将信息存入 etcd，当需要获取和操作这些数据时，则通过 API Server 提供的 REST 接口（用 GET、LIST 或 WATCH 方法）来实现，从而实现各模块之间的信息交互。</p>
<ul>
<li>如 kubelet 进程与 API Server 的交互：每个 Node 上的 kubelet 每隔一个时间周期， 就会调用一次 API Server 的REST 接口报告自身状态，API Server 在接收到这些信息后，会将节点状态信息更新到 etcd 中。</li>
<li>如 kube-controller-manager 进 程 与 API Server 的 交 互 ：kube-controller- manager 中的 Node Controller 模块通过 API Server 提供的 Watch 接口实时监控Node 的信息，并做相应处理。</li>
<li>如 kube-scheduler 进程与 API Server 的交互：Scheduler 通过 API Server 的Watch 接口监听到新建 Pod 副本的信息后，会检索所有符合该 Pod 要求的 Node 列表，开始执行 Pod 调度逻辑，在调度成功后将 Pod 绑定到目标节点上。</li>
</ul>
<h3 id="11-Controller-Manager"><a href="#11-Controller-Manager" class="headerlink" title="11.Controller Manager"></a>11.Controller Manager</h3><ul>
<li>Controller Manager 是集群的大脑，是确保整个集群动起来的关键； </li>
<li>作用是确保 Kubernetes 遵循声明式系统规范，确保系统的真实状态（Actual State）与用户定义的期望状态（Desired State）一致； </li>
<li>Controller Manager 是多个控制器的组合，每个 Controller 事实上都是一个 control loop，负责侦听其管控的对象，当对象发生变更时完成配置； </li>
<li>Controller 配置失败通常会触发自动重试，整个集群会在控制器不断重试的机制下确保最终一致性（ Eventual Consistency）。</li>
</ul>
<h3 id="12-Controller-的工作流程及原理"><a href="#12-Controller-的工作流程及原理" class="headerlink" title="12.Controller 的工作流程及原理"></a>12.Controller 的工作流程及原理</h3><p>核心还是生产者消费者模型， 通过Informer 和Lister 进行 监听和全量的消息获取</p>
<p>获取到消息(task) 后， 基于不同的EventHandler， 将时间放到不同的生产队列里面， 然后通过多个worker并发的进行事件消费完成最终的配置；</p>
<p><img src="/img/1695131651452.png" alt="1695131651452"></p>
<p><strong>Informer 的内部机制</strong></p>
<p>Informer提供了controller进行事件消费的框架 or 模型</p>
<p><img src="/img/1695131454182.png" alt="1695131454182"></p>
<ul>
<li>Reflector： 解析数据为内存struct对象</li>
<li>Delta Fifo Queue： 环形内存对象</li>
<li>Indexer: informer 为对象创建的索引， 用来提供键值读取</li>
<li>Tread Safe Store: 线程安全的存储结构，数据 与apiserver保持一致性</li>
<li>Informer：接收事件，并分配事件到对应EventHandler</li>
</ul>
<h3 id="13-Kubernetes-Scheduler作用及原理"><a href="#13-Kubernetes-Scheduler作用及原理" class="headerlink" title="13.Kubernetes Scheduler作用及原理"></a>13.Kubernetes Scheduler作用及原理</h3><p>特殊的 Controller，工作原理与其他控制器无差别。 </p>
<p>Scheduler 的特殊职责在于监控当前集群所有未调度的 Pod，并且获取当前集群所有节点的健康状况和资源使用情况，为待调度 Pod 选择最佳计算节点，完成调度。 </p>
<p>调度阶段分为： </p>
<ul>
<li>Predict：过滤不能满足业务需求的节点，如资源不足、端口冲突等。 </li>
<li>Priority：按既定要素将满足调度需求的节点评分，选择最佳节点。 </li>
<li>Bind：将计算节点与 Pod 绑定，完成调度。</li>
</ul>
<p>调度需要充分考虑诸多因素：</p>
<ul>
<li>公平调度</li>
<li>资源高效利用</li>
<li>Qos</li>
<li>affiniy   、 anti-affinity</li>
<li>数据本地化</li>
<li>内部负载干扰</li>
<li>deadlines</li>
</ul>
<p><img src="/img/1695132723654.png" alt="1695132723654"></p>
<p><strong>Predicates</strong></p>
<p>在 Kubernetes 中，为 Pod 筛选可用节点的方法通常包括以下几种：</p>
<ol>
<li>静态匹配：根据 Pod 的 <code>nodeSelector</code> 字段，为 Pod 指定一个或多个目标节点。这种方式适用于有特定节点要求的 Pod，如需要运行在特定的节点或特定类型的节点上。</li>
<li>亲和性规则：根据 Pod 的 <code>affinity/anti-affinity</code> 字段，为 Pod 指定一个或多个节点亲和或互斥的标签，然后在节点标签中匹配这些标签。这种方式适用于需要控制 Pod 和节点之间关系的场景，如需要将相关的 Pod 调度到同一个节点上。</li>
<li>资源匹配：根据节点的资源使用情况，筛选出空闲的节点，然后将 Pod 调度到其中。这种方式适用于资源敏感的 Pod，如需要大量 CPU 和内存资源的 Pod。</li>
<li>路由匹配：根据节点的位置和拓扑结构，筛选出网络拓扑上最近的节点。这种方式适用于需要快速访问其他节点的 Pod。</li>
</ol>
<p>在 <code>kube-scheduler</code> 中，这些方法会组合起来，对每个 Pod 进行筛选和评分，然后选择得分最高的节点作为调度目标。同时，Kubernetes 还支持用户自定义调度策略，可以通过修改 <code>kube-scheduler</code> 的配置文件，定义自己的调度器算法。</p>
<p><strong>Priorities</strong></p>
<p>在 Kubernetes 中，为了将 Pod 调度到最优的节点上，调度器会根据一定的规则对每个节点进行评分，最终选择得分最高的节点。评分规则的定义在 <code>kube-scheduler</code> 的配置文件中，可以通过修改该文件来定义自己的评分规则。</p>
<p>一般而言，Kubernetes 的评分规则会包括以下几个方面：</p>
<ol>
<li>节点资源的可用性：调度器会根据节点的 CPU、内存、存储等资源使用情况，评估节点资源的可用性。这个评估过程一般包括计算出节点的资源使用率，以及与 Pod 的资源需求进行比较。</li>
<li>Pod 亲和性规则的匹配情况：如果 Pod 定义了亲和性规则，调度器会根据这些规则，评估节点与 Pod 之间的亲和性匹配程度。例如，如果 Pod 需要调度到和另一个 Pod 在同一个节点上，调度器会评估节点上是否已经有符合条件的 Pod。</li>
<li>节点和 Pod 之间的拓扑关系：如果 Pod 和节点之间存在网络拓扑关系，调度器会考虑这些关系，评估节点和 Pod 之间的网络距离。例如，如果 Pod 需要快速访问某个服务，调度器会评估距离最近的节点是否可以满足这个需求。</li>
<li>其他因素：除了以上几个方面，调度器还可以考虑其他因素，如节点的稳定性、负载均衡等。例如，如果节点已经运行了过多的 Pod，调度器可能会选择其他节点，以保证集群的负载均衡。</li>
</ol>
<h3 id="14-Scheduler-绑定Pod到-worker-流程"><a href="#14-Scheduler-绑定Pod到-worker-流程" class="headerlink" title="14.Scheduler 绑定Pod到 worker 流程"></a>14.Scheduler 绑定Pod到 worker 流程</h3><p>Kubernetes Scheduler 根据如下两种调度算法将 Pod 绑定到最合适的工作节点：</p>
<ul>
<li>预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube- scheduler 根据预选策略过滤掉不满足策略的 Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如“Node 的label 必须与 Pod 的Selector 一致”。</li>
<li>优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的 Nodes 进行打分排名，选择得分最高的 Node。例如，资源越富裕、负载越小的 Node 可能具有越高的排名。</li>
</ul>
<h3 id="15-Controller的协同工作原理"><a href="#15-Controller的协同工作原理" class="headerlink" title="15.Controller的协同工作原理"></a>15.Controller的协同工作原理</h3><p>以Deployment的创建为例</p>
<ul>
<li>Api Server进行认证鉴权准入后， 将Deployment对象放入etcd</li>
<li>Deployment Controller 会监听到Deployment对象， 创建ReplicaSet 副本集，并发送给apiserver</li>
<li>ReplicaSet  Controller 监听到ReplicaSet对象， 创建Pod对象，并发送给apiserver</li>
<li>Scheduler 监听到未被调度的Pod对象， 根据当前集群的所有节点， 调度器会按某种算法，选择适合部署的节点，将Pod对象和Node绑定，并重新发送给apiserver</li>
<li>Kubelet会关注当前ApiServer和本Node相关的Pod有哪些，并通过docker进行create pod，后续还需要挂载网络和磁盘。</li>
</ul>
<p><img src="/img/1695131950421.png" alt="1695131950421"></p>
<h2 id="Kubernetes-常用对象"><a href="#Kubernetes-常用对象" class="headerlink" title="Kubernetes 常用对象"></a>Kubernetes 常用对象</h2><h3 id="1-简述-Kubernetes-RC-的机制"><a href="#1-简述-Kubernetes-RC-的机制" class="headerlink" title="1.简述 Kubernetes RC 的机制"></a>1.简述 Kubernetes RC 的机制</h3><p>Replication Controller 用来管理Pod 的副本，保证集群中存在指定数量的Pod副本。当定义了RC 并提交至Kubernetes集群中之后， Master节点上的Controller Manager组件获悉，并同时巡检系统中当前存货的目标Pod，确保Pod实例数量刚好等于此RC的期望值，若存在过多的Pod副本在运行， 系统会停止一些Pod，反之则自动创建一些Pod</p>
<h3 id="2-ReplicationController和ReplicaSet区别"><a href="#2-ReplicationController和ReplicaSet区别" class="headerlink" title="2.ReplicationController和ReplicaSet区别"></a>2.ReplicationController和ReplicaSet区别</h3><p>K8s新版本中， Replica Set 取代了 Replication Controller， 他们的功能类似， 都是确保在任何给定时间运行指定数量的Pod副本。不同之处在与RC使用基于集合的选择器， 而Replication Controller 使用基于权限的选择器。</p>
<h3 id="3-Statefulset-与-Deployment-的差异"><a href="#3-Statefulset-与-Deployment-的差异" class="headerlink" title="3.Statefulset 与 Deployment 的差异"></a>3.Statefulset 与 Deployment 的差异</h3><ul>
<li>身份标识<ul>
<li>StatefulSet Controller 为每个 Pod 编号，序号从0开始。</li>
</ul>
</li>
<li>数据存储<ul>
<li>StatefulSet 允许用户定义 volumeClaimTemplates，Pod 被创建的同时，Kubernetes 会以volumeClaimTemplates 中定义的模板创建存储卷，并挂载给 Pod。</li>
</ul>
</li>
<li>StatefulSet 的升级策略不同<ul>
<li>滚动升级</li>
<li>onDelete</li>
<li>分片升级</li>
</ul>
</li>
</ul>
<h3 id="4-Kubernetes-deployment-升级过程"><a href="#4-Kubernetes-deployment-升级过程" class="headerlink" title="4.Kubernetes deployment 升级过程"></a>4.Kubernetes deployment 升级过程</h3><ul>
<li>初始创建 Deployment 时，系统创建了一个 ReplicaSet，并按用户的需求创建了对应数量的 Pod 副本。</li>
<li>当更新 Deployment 时，系统创建了一个新的 ReplicaSet，并将其副本数量扩展到 1，然后将旧 ReplicaSet 缩减为1。</li>
<li>之后，系统继续按照相同的更新策略对新旧两个 ReplicaSet 进行逐个调整。</li>
<li>最后，新的 ReplicaSet 运行了对应个新版本 Pod 副本，旧的 ReplicaSet 副本数量则缩减为 0。</li>
</ul>
<h3 id="5-Kubernetes-deployment-升级策略"><a href="#5-Kubernetes-deployment-升级策略" class="headerlink" title="5.Kubernetes deployment 升级策略"></a>5.Kubernetes deployment 升级策略</h3><p>在 Deployment 的定义中，可以通过 spec.strategy 指定 Pod 更新的策略，目前支持两种策略：Recreate（重建）和 RollingUpdate（滚动更新），默认值为RollingUpdate。</p>
<ul>
<li>Recreate：设置 spec.strategy.type=Recreate，表示 Deployment 在更新 Pod 时，会先杀掉所有正在运行的Pod，然后创建新的 Pod。</li>
<li>RollingUpdate：设置 spec.strategy.type=RollingUpdate，表示 Deployment 会以滚动更新的方式来逐个更新 Pod。同时，可以通过设置spec.strategy.rollingUpdate 下的两个参数（maxUnavailable 和maxSurge） 来控制滚动更新的过程。<ul>
<li>MaxUnavailable：滚动过程中最多有多少个 Pod 不可用；</li>
<li>MaxSurge：滚动过程中最多存在多少个 Pod 超过预期 replicas 数量</li>
</ul>
</li>
</ul>
<h3 id="6-Kubernetes-自动扩容机制？"><a href="#6-Kubernetes-自动扩容机制？" class="headerlink" title="6.Kubernetes 自动扩容机制？"></a>6.Kubernetes 自动扩容机制？</h3><p>Kubernetes 使用 Horizontal Pod Autoscaler（HPA）的控制器实现基于 CPU 使用率进行自动 Pod 扩缩容的功能。HPA 控制器周期性地监测目标 Pod 的资源性能指标，并与 HPA 资源对象中的扩缩容条件进行对比，在满足条件时对 Pod 副本数量进行调整。</p>
<ul>
<li><p>HPA 原理</p>
<p>Kubernetes 中的某个 Metrics Server（Heapster 或自定义 Metrics Server）持续采集所有 Pod 副本的指标数据。HPA 控制器通过 Metrics Server 的 API（Heapster 的API 或聚合 API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标Pod 副本数量。</p>
<p>当目标 Pod 副本数量与当前副本数量不同时，HPA 控制器就向 Pod 的副本控制器（Deployment、RC 或 ReplicaSet）发起 scale 操作，调整 Pod 的副本数量，完成扩缩容操作。</p>
</li>
</ul>
<h2 id="Pod生命周期和资源管理"><a href="#Pod生命周期和资源管理" class="headerlink" title="Pod生命周期和资源管理"></a>Pod生命周期和资源管理</h2><h3 id="1-Pod-可能位于的状态？"><a href="#1-Pod-可能位于的状态？" class="headerlink" title="1. Pod 可能位于的状态？"></a>1. Pod 可能位于的状态？</h3><ul>
<li>Pending：API Server 已经创建该 Pod，且 Pod 内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。</li>
<li>Running：Pod 内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态</li>
<li>Succeeded：Pod 内所有容器均成功执行退出，且不会重启。</li>
<li>Failed：Pod 内所有容器均已退出，但至少有一个容器退出为失败状态。</li>
<li>Unknown：由于某种原因无法获取该 Pod 状态，可能由于网络通信不畅导致。</li>
</ul>
<ol>
<li><h3 id="2-Pod-的常见调度方式？"><a href="#2-Pod-的常见调度方式？" class="headerlink" title="2.Pod 的常见调度方式？"></a>2.Pod 的常见调度方式？</h3></li>
</ol>
<p>Kubernetes 中，Pod 通常是容器的载体，主要有如下常见调度方式：</p>
<ul>
<li>Deployment 或 RC：该调度策略主要功能就是自动部署一个容器应用的多份副本， 以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</li>
<li>NodeSelector：定向调度，当需要手动指定将 Pod 调度到特定 Node 上，可以通过 Node 的标签（Label）和 Pod 的nodeSelector 属性相匹配。</li>
<li>NodeAffinity 亲和性调度：亲和性调度机制极大的扩展了 Pod 的调度能力，目前有两种节点亲和力表达：<ul>
<li>requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度 Pod 至 Node 上（类似 nodeSelector，语法不同）。</li>
<li>preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的 Node 的节点，但不强求，多个优先级规则还可以设置权重值。</li>
</ul>
</li>
<li>Taints 和 Tolerations（污点和容忍）；<ul>
<li>Taint：使 Node 拒绝特定 Pod 运行；</li>
<li>Toleration：为 Pod 的属性，表示 Pod 能容忍（运行）标注了 Taint 的 Node。 </li>
</ul>
</li>
</ul>
<p><strong>通过NodeAffinity选择节点</strong></p>
<p>相较于使用nodeSlector, 更具有普遍性和扩展性</p>
<p><img src="/img/1697550229461.png" alt="1697550229461"></p>
<p><strong>Taints  和  Tolerations</strong></p>
<p>用来标记Node， 保证Pod不被调度到打了标的node上</p>
<p><img src="/img/1697551524292.png" alt="1697551524292"></p>
<h3 id="3-创建一个Pod的主要流程？"><a href="#3-创建一个Pod的主要流程？" class="headerlink" title="3.创建一个Pod的主要流程？"></a>3.创建一个Pod的主要流程？</h3><p>Kubernetes 中创建一个 Pod 涉及多个组件之间联动，主要流程如下：</p>
<ol>
<li>客户端提交 Pod 的配置信息（可以是 yaml 文件定义的信息）到 kube- apiserver。</li>
<li>Apiserver 收到指令后，通过对应的kubeconfig进行认证，认证后将yaml中的配置信息存储到etcd。</li>
<li>Controller-Manager 通过apiserver的watch 接口发先了Pod的信息的更新，执行该资源锁依赖的拓扑结构整合，整合后将对应的信息交给apiserver，apiserver写到etcd，此时Pod已经可以被调度了。</li>
<li>Kube-scheduler 检测到 pod 信息会开始调度预选，会先过滤掉不符合 Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行 pod 的节点，绑定信息后交给apiserver， apiserver写到etcd，然后将Pod交给kubelet。</li>
<li>kubelet收到pod后， 调用CNI接口创建Pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载。</li>
<li>网络、容器、存储创建完成后Pod创建完成，等业务进程启动后，Pod运行成功；</li>
</ol>
<h3 id="4-Kubernetes中Pod的重启策略？"><a href="#4-Kubernetes中Pod的重启策略？" class="headerlink" title="4.Kubernetes中Pod的重启策略？"></a>4.Kubernetes中Pod的重启策略？</h3><p>答：Pod 重启策略（RestartPolicy）应用于 Pod 所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 的设置来进行相应操作。</p>
<p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值为 Always。</p>
<ul>
<li>Always：当容器失效时，由 kubelet 自动重启该容器；</li>
<li>OnFailure：当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器；</li>
<li>Never：不论容器运行状态如何，kubelet 都不会重启该容器。</li>
</ul>
<h3 id="5-Pod-的健康检查方式？"><a href="#5-Pod-的健康检查方式？" class="headerlink" title="5.Pod 的健康检查方式？"></a>5.Pod 的健康检查方式？</h3><p>对 Pod 的健康检查可以通过两类探针来检查：LivenessProbe 和ReadinessProbe。</p>
<ul>
<li>LivenessProbe 探针：用于判断容器是否存活（running 状态），如果LivenessProbe 探针探测到容器不健康，则 kubelet 将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含 LivenessProbe 探针，kubelet 认为该容器的 LivenessProbe 探针返回值用于是“Success”。</li>
<li>ReadineeProbe 探针：用于判断容器是否启动完成（ready 状态）。如果ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的Endpoint 中删除包含该容器所在 Pod 的Eedpoint。</li>
<li>startupProbe 探针：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针 kill 掉。 </li>
</ul>
<h3 id="6-Pod-的LivenessProbe-探针种类？"><a href="#6-Pod-的LivenessProbe-探针种类？" class="headerlink" title="6.Pod 的LivenessProbe 探针种类？"></a>6.Pod 的LivenessProbe 探针种类？</h3><p>kubelet 定期执行LivenessProbe 探针来诊断容器的健康状态，通常有以下三种方式：</p>
<ul>
<li>ExecAction：在容器内执行一个命令，若返回码为 0，则表明容器健康。</li>
<li>TCPSocketAction：通过容器的 IP 地址和端口号执行 TCP 检查，若能建立 TCP 连接，则表明容器健康。</li>
<li>HTTPGetAction：通过容器的 IP 地址、端口号及路径调用 HTTP Get 方法，若响应的状态码大于等于 200 且小于 400，则表明容器健康。 </li>
</ul>
<h3 id="7-pod-中-readness-和liveness-的区别"><a href="#7-pod-中-readness-和liveness-的区别" class="headerlink" title="7.pod 中 readness 和liveness 的区别"></a>7.pod 中 readness 和liveness 的区别</h3><p>readness：用于探测容器是否已经准备好接受流量，如果readness探测失败，那么kubelet会把Pod的IP从service的endpoint中删除，这样流量就不会转发到该Pod上。当readness探测成功后，kubelet会把Pod的IP加入到service的endpoint中，这样流量就可以转发到该Pod上。<br>liveless：用于探测容器是否还在运行，如果liveness探测失败，那么kubelet会杀死容器，并根据容器的重启策略进行重启。</p>
<h3 id="8-Pod-如何实现对节点的资源控制？"><a href="#8-Pod-如何实现对节点的资源控制？" class="headerlink" title="8.Pod 如何实现对节点的资源控制？"></a>8.Pod 如何实现对节点的资源控制？</h3><p>Kubernetes 集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。当前 Kubernetes 集群中的计算资源主要包括 CPU、GPU 及Memory。</p>
<p>CPU 与Memory 是被 Pod 使用的，因此在配置 Pod 时可以通过参数 CPU Request 及Memory Request 为其中的每个容器指定所需使用的 CPU 与Memory 量，Kubernetes 会根据 Request 的值去查找有足够资源的 Node 来调度此Pod。</p>
<p>通常，一个程序所使用的 CPU 与 Memory 是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU 和Memory 的使用量也会增加。 </p>
<h3 id="Pod如何进行资源限制"><a href="#Pod如何进行资源限制" class="headerlink" title="Pod如何进行资源限制"></a><strong>Pod如何进行资源限制</strong></h3><p>Kubernetes 通过 Cgroups 提供容器资源管理的功能，可以限制每个容器的 CPU 和内存使用，比如对于刚才创建的 deployment，可以通过下面的命令限制 nginx 容器最多只用 50% 的 CPU 和 128MB 的内存： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">set</span> resources deployment nginx-app -c=nginx --limits=cpu=500m, memory=128Mi  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> deployment <span class="string">"nginx"</span> resource requirements updated</span></span><br></pre></td></tr></table></figure>

<p><code>等同于在每个 Pod 中设置 resources limits</code></p>
<p><img src="/img/1695306849887.png" alt="1695306849887"></p>
<h3 id="9-Pod-Requests-Limits-对Pod调度影响"><a href="#9-Pod-Requests-Limits-对Pod调度影响" class="headerlink" title="9.Pod Requests\Limits 对Pod调度影响"></a>9.Pod Requests\Limits 对Pod调度影响</h3><p><strong>作用</strong></p>
<p><code>requests</code> 和 <code>limits</code> 的区别在于：</p>
<ul>
<li><code>requests</code> 表示容器所需的资源数量，确保 Pod 能够启动和运行。</li>
<li><code>limits</code> 表示容器能够使用的最大资源数量，确保容器的资源使用量不会超过指定的限制。</li>
</ul>
<p>当一个 Pod 创建成功时，Kubernetes 调度器（Scheduler）会为该 Pod 选择一个节点来执行。</p>
<p>对于每种计算资源（CPU 和Memory）而言，每个节点都有一个能用于运行 Pod 的最大容量值。</p>
<p>调度器在调度时，首先要确保调度后该节点上所有 Pod 的 CPU 和内存的 Requests 总和，不超过该节点能提供给 Pod 使用的 CPU 和Memory 的最大容量值。</p>
<h3 id="10-QoS-模型"><a href="#10-QoS-模型" class="headerlink" title="10.QoS 模型"></a>10.QoS 模型</h3><p>当 Pod 里的每一个 Container 都同时设置了 requests 和 limits，并且 requests 和limits 值相等的时候，这个 Pod 就属于<code>Guaranteed</code> 类别。当 Pod 仅设置了 limits 没有设置 requests 的时候，Kubernetes 会自动为它设置与 limits 相同的 requests 值，所以，这也属于 <code>Guaranteed</code>情况。</p>
<p>而当 Pod 不满足 Guaranteed 的条件，但至少有一个 Container 设置了 requests。那么这个 Pod 就会被划分到 <code>Burstable</code> 类别。</p>
<p>而如果一个 Pod 既没有设置 requests，也没有设置 limits，那么它的 QoS 类别就是<code>BestEffort</code>。</p>
<p>QoS 划分的主要应用场景，是当宿主机资源紧张的时候，kubelet 对 Pod 进行Eviction（即资源回收）时需要用到的。当 Kubernetes 所管理的宿主机上不可压缩资源短缺时，就有可能触发Eviction。</p>
<p>Eviction 发生的时候，kubelet 具体会挑选哪些 Pod 进行删除操作，就需要参考这些Pod 的 QoS 类别了。</p>
<p>删除顺序 BestEffort -&gt; Burstable -&gt; Guaranteed</p>
<h3 id="11-kubernets-cpuset"><a href="#11-kubernets-cpuset" class="headerlink" title="11.kubernets cpuset"></a>11.kubernets cpuset</h3><p>我们知道，在使用容器的时候，你可以通过设置 cpuset 把容器绑定到某个 CPU 的核上，而不是像 cpushare 那样共享 CPU 的计算能力。这种情况下，由于操作系统在 CPU 之间进行上下文切换的次数大大减少，容器里应用的性 能会得到大幅提升。</p>
<p><strong>在 Kubernetes 里又该如何实现呢？</strong></p>
<p>首先，你的 Pod 必须是 Guaranteed 的 QoS 类型；</p>
<p>然后，你只需要将 Pod 的 CPU 资源的 requests 和 limits 设置为同一个相等的整数值即可。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">containers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"> <span class="attr">resources:</span></span><br><span class="line"> <span class="attr">limits:</span></span><br><span class="line"> <span class="attr">memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"> <span class="attr">cpu:</span> <span class="string">"2"</span></span><br><span class="line"> <span class="attr">requests:</span></span><br><span class="line"> <span class="attr">memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"> <span class="attr">cpu:</span> <span class="string">"2"</span></span><br></pre></td></tr></table></figure>

<p>这时候，该 Pod 就会被绑定在 2 个独占的 CPU 核上。当然，具体是哪两个 CPU 核，是由 kubelet 为你分配的。</p>
<h3 id="12-节点宕机后Pod的驱逐过程"><a href="#12-节点宕机后Pod的驱逐过程" class="headerlink" title="12.节点宕机后Pod的驱逐过程"></a>12.节点宕机后Pod的驱逐过程</h3><p>当node节点由于某些原因（网络、宕机）会被认定被（UNKNOW、FALSE状态），当时间超过了pod-eviction-timeout时，那么节点上的Pod都会被node-controller删除。</p>
<h3 id="13-pod-启动失败以及排查"><a href="#13-pod-启动失败以及排查" class="headerlink" title="13.pod 启动失败以及排查"></a>13.pod 启动失败以及排查</h3><ul>
<li>一般查看系统资源是否满足，然后就是查看pod日志看看原因</li>
<li>describe pod 通过这个参数查看pod的失败原因</li>
<li>还有可以看组件日志，apiserver组件等日志， 有没有异常</li>
<li>访问不到看看网络插件和日志， 还有就是dns状态和日志</li>
</ul>
<h3 id="14-init-容器的介绍和作用"><a href="#14-init-容器的介绍和作用" class="headerlink" title="14.init 容器的介绍和作用"></a>14.init 容器的介绍和作用</h3><p>Kubernetes中的init容器（Init Container）是在Pod中首先运行的一种特殊容器。Init容器的作用是在正常容器（Application Container）启动之前执行一些初始化任务，例如初始化数据库、创建配置文件、下载数据等。Init容器只有在成功完成后才会运行正常容器，如果Init容器失败，正常容器将不会启动。</p>
<p>Init容器和正常容器共享Pod的网络命名空间和卷存储，但是它们有独立的进程空间。在Pod中可以定义多个Init容器，每个Init容器都将按照定义顺序依次执行。这种机制为应用程序提供了更高的可靠性和灵活性。</p>
<h3 id="15-PodSecurityPolicy实现哪些安全策略"><a href="#15-PodSecurityPolicy实现哪些安全策略" class="headerlink" title="15.PodSecurityPolicy实现哪些安全策略"></a>15.PodSecurityPolicy实现哪些安全策略</h3><p>在 PodSecurityPolicy 对象中可以设置不同字段来控制 Pod 运行时的各种安全策略， 常见的有：</p>
<ul>
<li>特权模式：privileged 是否允许 Pod 以特权模式运行。</li>
<li>宿主机资源：控制 Pod 对宿主机资源的控制，如 hostPID：是否允许 Pod 共享宿主机的进程空间。</li>
<li>用户和组：设置运行容器的用户 ID（范围）或组（范围）。</li>
<li>提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限， 通常在设置非 root 用户（MustRunAsNonRoot）时进行设置。</li>
<li>SELinux：进行 SELinux 的相关配置。 </li>
</ul>
<h2 id="kubernetes流量控制"><a href="#kubernetes流量控制" class="headerlink" title="kubernetes流量控制"></a>kubernetes流量控制</h2><h3 id="1-Headless-Service的作用？"><a href="#1-Headless-Service的作用？" class="headerlink" title="1.Headless Service的作用？"></a>1.Headless Service的作用？</h3><p>在某些应用场景中，若需要人为指定负载均衡器，不使用 Service 提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。Kubernetes 提供了Headless Service 来实现这种功能，即不为 Service 设置 ClusterIP（入口 IP 地址），仅通过 Label Selector 将后端的 Pod 列表返回给调用的客户端。</p>
<p>对于 Headless Service，Kube-proxy 创建的是一组 DNS 记录，用于解析到每个 Pod 的 IP 地址。这样，客户端就可以通过 DNS 解析来得到 Pod 的 IP 地址，并与它直接建立连接，完全绕过了 Kube-proxy 组件。</p>
<h3 id="2-Kubernetes-Service-及类型？"><a href="#2-Kubernetes-Service-及类型？" class="headerlink" title="2.Kubernetes Service 及类型？"></a>2.Kubernetes Service 及类型？</h3><p>通过创建 Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址， 并且将请求负载分发到后端的各个容器应用上。其主要类型有：</p>
<ul>
<li>ClusterIP：虚拟的服务 IP 地址，该地址用于 Kubernetes 集群内部的 Pod 访问， 在 Node 上 kube-proxy 通过设置的 iptables 规则进行转发；</li>
<li>NodePort：使用宿主机的端口，使能够访问各 Node 的外部客户端通过 Node 的 IP 地址和端口号就能访问服务；</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，需要在spec.status.loadBalancer 字段指定外部负载均衡器的 IP 地址，通常用于公有云。</li>
<li>ExternalName Service(不定义Selector 的Service)： 可以用来连接外部访问， 类似于创建了一个访问集群外部服务的一个负载均衡</li>
<li>Headless Service：不使用 Service 提供的默认负载均衡的功能，仅通过 Label Selector 将后端的 Pod 列表返回给调用的客户端。</li>
</ul>
<h3 id="3-Service-分发后端的策略？"><a href="#3-Service-分发后端的策略？" class="headerlink" title="3.Service 分发后端的策略？"></a>3.Service 分发后端的策略？</h3><p>Service 负载分发的策略有：RoundRobin 和 SessionAffinity</p>
<ul>
<li>RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个 Pod 上。</li>
<li>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，即第 1 次将某个客户端发起的请求转发到后端的某个 Pod 上，之后从相同的客户端发起的请求都将被转发到后端相同的 Pod 上。</li>
</ul>
<h3 id="4-外部如何访问K8s集群内的服务？"><a href="#4-外部如何访问K8s集群内的服务？" class="headerlink" title="4.外部如何访问K8s集群内的服务？"></a>4.外部如何访问K8s集群内的服务？</h3><ul>
<li>映射 Pod 到物理机：将 Pod 端口号映射到宿主机，即在 Pod 中采用hostPort 方式，以使客户端应用能够通过物理机访问容器应用。</li>
<li>映射 Service 到物理机：将 Service 端口号映射到宿主机，即在 Service 中采用nodePort 方式，以使客户端应用能够通过物理机访问容器应用。</li>
<li>映射 Sercie 到LoadBalancer：通过设置 LoadBalancer 映射到云服务商提供的LoadBalancer 地址。这种用法仅用于在公有云服务提供商的云平台上设置Service 的场景。</li>
</ul>
<h3 id="5-kube-proxy-的作用"><a href="#5-kube-proxy-的作用" class="headerlink" title="5.kube-proxy 的作用"></a>5.kube-proxy 的作用</h3><ul>
<li>监控集群中用户发布的服务Service，并完成负载均衡配置。 </li>
<li>每个节点的 Kube-Proxy 都会配置相同的负载均衡策略，使得整个集群的服务发现建立在分布式负载均衡器之上，服务调用无需经过额外的网络跳转（Network Hop）。 </li>
<li>负载均衡配置基于不同插件实现： <ul>
<li>userspace。 </li>
<li>操作系统网络协议栈不同的 Hooks 点和插件： <ul>
<li>iptables； </li>
<li>ipvs。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-kube-proxy-的三种工作模式"><a href="#6-kube-proxy-的三种工作模式" class="headerlink" title="6.kube-proxy 的三种工作模式"></a>6.kube-proxy 的三种工作模式</h3><ul>
<li><p>userspace模式</p>
<p>该模式下kube-proxy 会为没一格Service 创建一个监听端口。发向Cluster IP 的请求被IPtables规则重定向到kube-proxy监听的端口上，kube-proxy 根据LB算法选择一个提供服务的Pod并和其建立连接。将请求转发到Pod上， 该模式充当一个四层LB的角色。</p>
</li>
<li><p>iptables模式</p>
<p>kube-proxy为service后端的每个pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到Pod IP。</p>
</li>
<li><p>ipvs模式</p>
<p>和iptables类似，监听Pod的变化并创建ipvs rules。ipvs 也是在kernel模式通过netfilter实现的，但是采用了hashtable来存储规则，因此在规则比较多的情况下，ipvs相对iptables转发效率更高。除此之外，ipvs支持更多的LB算法。如果要设计kube-proxy为ipvs模式，必须在操作系统中安装IPVS内核模块。</p>
</li>
</ul>
<h3 id="7-kube-proxy-ipvs原理"><a href="#7-kube-proxy-ipvs原理" class="headerlink" title="7.kube-proxy ipvs原理"></a>7.kube-proxy ipvs原理</h3><p>IPVS 在kubernetes 1.11中升级为GA稳定版。IPVS则专门用于高性能负载均衡，并使用更高效的数据结构(HASH表)， 允许几乎无线的规模扩张， 因此被kube-proxy采纳为最新模式。</p>
<p>在IPVS模式下， 使用iptables的扩展ipset， 而不是直接调用iptables来生成规则链。iptables规则链是一个线性的数据结构，ipset则引入了带索引的数据结构， 因此当规则很多时， 也可以很高效的查找和匹配。</p>
<p>可以将ipset 理解为一个IP段的集合， 这个集合的内容可以是IP地址、IP网段、端口等。iptables 可以直接添加规则对这个“可变的结合”进行操作，这样做的好处在与可以大大减少iptables的规则数量，从而减少性能损耗</p>
<h3 id="8-kube-proxy-ipvs-和iptables-的异同"><a href="#8-kube-proxy-ipvs-和iptables-的异同" class="headerlink" title="8.kube-proxy ipvs 和iptables 的异同"></a>8.kube-proxy ipvs 和iptables 的异同</h3><p>iptables与IPVS都是基于Netfilter实现的， 但因为定位不同， 二者有着本质的差别：iptables 是为防火墙而设计的, 原理是修改iptable 的dnat规则实现； IPVS 则是专门用于高性能负载均衡， 不使用dnat规则改用更高效的数据结构（HASH表），允许几乎无限的规模扩张。</p>
<p>与iptables相比，IPVS 拥有以下明显优势：</p>
<ol>
<li>为大型集群提供了更好的可扩展性和性能；</li>
<li>支持比iptables更复杂的负载均衡算法</li>
<li>支持服务器健康检查和连接重试等功能；</li>
<li>可以动态修改ipset的结合， 即使iptables的规则正在使用这个集合；</li>
</ol>
<h3 id="9-core-dns组件介绍"><a href="#9-core-dns组件介绍" class="headerlink" title="9.core dns组件介绍"></a>9.core dns组件介绍</h3><p>coreDNS包含一个内存态DNS，以及与Italyconroller类似的控制器</p>
<p>CoreDNS的实现原理是， 控制器监听Service和Endpoint的变化并配置DNS，客户端Pod再进行域名解析时，从CoreDNS 中查询服务对应的地址记录</p>
<h3 id="10-Kubernetes-ingress介绍？"><a href="#10-Kubernetes-ingress介绍？" class="headerlink" title="10.Kubernetes ingress介绍？"></a>10.Kubernetes ingress介绍？</h3><p>Kubernetes 的Ingress 资源对象，用于将不同 URL 的访问请求转发到后端不同的 Service，以实现 HTTP 层的业务路由机制（L7负载均衡）。</p>
<p>Kubernetes 使用了 Ingress 策略和 Ingress Controller，两者结合并实现了一个完整的Ingress 负载均衡器。使用Ingress 进行负载分发时，Ingress Controller 基于Ingress 规则将客户端请求直接转发到 Service 对应的后端Endpoint（Pod）上，从而跳过 kube-proxy 的转发功能，kube-proxy 不再起作用，全过程为：ingress controller + ingress 规则&gt; services。</p>
<p>同时当 Ingress Controller 提供的是对外服务，则实际上实现的是边缘路由器的功能。</p>
<h3 id="11-Service-Mesh-介绍"><a href="#11-Service-Mesh-介绍" class="headerlink" title="11.Service Mesh 介绍"></a>11.Service Mesh 介绍</h3><p>服务网格(Service Mesh) 这个术语通常用于描述构成这些应用程序的微服务网络以及应用之间的交互。</p>
<p>随着规模和复杂性的增长，服务网格越来越难以理解和管理。 它的需求包括服务发现、负载均衡、故障恢复、指标收集和监控以及通常更加复杂的运维需求，例如 <strong>A/B 测试、金丝雀发布、限流、访问控制和端到端认证等。</strong></p>
<p>可以理解为服务调用链路上的所有能力， 加起来组成的网格状的结构</p>
<p>使用Servcie Mesh 可以做到如下功能：</p>
<ul>
<li>Http、Grpc 和TCP流量的自动负载均衡。</li>
<li>通过丰富的路由规则、重试、故障转移和故障注入，可以对流量进行细粒度的控制。</li>
<li>可插入的策略层和配置API，支持访问控制、速率限制和配额。</li>
<li>对出入集群入口和出口中所有流量的自动度量指标、日志记录和跟踪。</li>
<li>通过强大的基于身份验证和授权，在集群中实现安全的服务间通信。</li>
</ul>
<h3 id="12-istio-架构"><a href="#12-istio-架构" class="headerlink" title="12.istio 架构"></a>12.istio 架构</h3><ul>
<li>数据平面： SideCar 方式部署的 Proxy， 负责网络通信（上面介绍的服务网格， 其实是通过数据面实现的）；</li>
<li>控制平面： 负责管理和配置代理来进行路由流量，就是负责控制数据面的部署和配置；</li>
</ul>
<p><img src="/img/1700528361306.png" alt="1700528361306"></p>
<p>watch api service， 监控state信息： Service 、 Pod、 Endpoint 等信息， 将Istio 配置和 State 信息结合后下发给Envoy， 作为各Pod的Proxy。</p>
<h3 id="13-istio-原理"><a href="#13-istio-原理" class="headerlink" title="13.istio 原理"></a>13.istio 原理</h3><ul>
<li>istiod: 负责监听集群所有service 、pod、 endpoint 、secret、以及istio自身对象的变化，并负责将集群的信息push给envoy  mesh实例</li>
<li>istio-ingressgateway：进入网络的所有流量都会通过ingress-envoy进行传输</li>
<li>istio-egressgateway ：离开网络的所有流量都会通过egress-envoy进行传输</li>
</ul>
<p><img src="/img/1700616123027.png" alt="1700616123027"></p>
<ul>
<li>先为pod注入sidecar， 注入Istio side car 的结果是会有  istio-init  和  istio-proxy 两个pod</li>
<li>通过istio-init， 修改iptable， 将应用容器的所有流量都转发哦到Envoy的容器中</li>
<li>通过istio-proxy， 实际为envoy容器， 用来进行虚拟路由， 将流量转发给实际的endpoint。</li>
</ul>
<p><strong>istio配置对象</strong></p>
<ul>
<li>VirtualService: 用于定义对特定目标服务的一组流量规则。描述一个具体的服务对象，包含了对流量的各种处理。可以实现对服务的请求路由、错误注入、流量切分、流量镜像、超时设置、请求重试等。</li>
<li>DestinationRule： VirtualService 路由生效后， 配置应用与请求的策略集，可以设置负载均衡策略和熔断， 还可以对Service 区分不同的版本；</li>
<li>ServiceEntry： 是通常用于在Istio服务网格之外启动对服务的请求</li>
<li>Gateway： 为Http/Tcp 流量配置负载均衡器，最常见的是在网格边缘的操作，以启用应用程序的入口流量。</li>
</ul>
<h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><h3 id="1-Kubernetes-kubelet-的作用"><a href="#1-Kubernetes-kubelet-的作用" class="headerlink" title="1.Kubernetes kubelet 的作用"></a>1.Kubernetes kubelet 的作用</h3><p>Kubernetes 的初始化系统（init system） </p>
<ul>
<li>从不同源获取 Pod 清单，并按需求启停 Pod 的核心组件： </li>
<li>Pod 清单可从本地文件目录，给定的 HTTPServer 或 Kube-APIServer 等源头获取； </li>
<li>Kubelet 将运行时，网络和存储抽象成了 CRI，CNI，CSI。 </li>
<li>负责汇报当前节点的资源信息和健康状态；</li>
<li>负责 Pod 的健康检查和状态汇报。</li>
</ul>
<h3 id="2-kubelet-如何监控Worker-节点资源"><a href="#2-kubelet-如何监控Worker-节点资源" class="headerlink" title="2.kubelet 如何监控Worker 节点资源"></a>2.kubelet 如何监控Worker 节点资源</h3><p>kubelet 使用 cAdvisor 对worker 节点资源进行监控。在 Kubernetes 系统中， cAdvisor 已被默认集成到 kubelet 组件内，当 kubelet 服务启动时，它会自动启动cAdvisor 服务，然后 cAdvisor 会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。</p>
<h3 id="3-简述-Kubernetes-CNI-模型"><a href="#3-简述-Kubernetes-CNI-模型" class="headerlink" title="3.简述 Kubernetes CNI 模型"></a>3.简述 Kubernetes CNI 模型</h3><p>CNI 提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对CNI 接口进行实现。CNI 仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在 CNI 模型中只涉及两个概念：容器和网络。</p>
<ul>
<li>容器（Container）：是拥有独立 Linux 网络命名空间的环境，例如使用 Docker 或 rkt 创建的容器。容器需要拥有自己的 Linux 网络命名空间，这是加入网络的必要条件。</li>
<li>网络（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的IP 地址，可以是容器、物理机或者其他网络设备（比如路由器）等。</li>
</ul>
<p>对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI 插件包括两种类型：CNI Plugin 和 IPAM（IP Address Management）Plugin。CNI Plugin 负责为容器配置网络资源，IPAM Plugin 负责对容器的 IP 地址进行分配和管理。IPAM Plugin 作为 CNI Plugin 的一部分，与 CNI Plugin 协同工作。</p>
<h3 id="4-Kubernetes-Calico-网络组件原理"><a href="#4-Kubernetes-Calico-网络组件原理" class="headerlink" title="4.Kubernetes Calico 网络组件原理"></a>4.Kubernetes Calico 网络组件原理</h3><p>Calico 是一个基于 BGP 的纯三层的网络方案，与 OpenStack、Kubernetes、AWS、GCE 等云平台都能够良好地集成。</p>
<p>Calico 在每个计算节点都利用 Linux Kernel 实现了一个高效的 vRouter 来负责数据转发。每个 vRouter 都通过 BGP 协议把在本节点上运行的容器的路由信息向整个Calico 网络广播，并自动设置到达其他节点的路由转发规则。</p>
<p>Calico 保证所有容器之间的数据流量都是通过 IP 路由的方式完成互联互通的。Calico 节点组网时可以直接利用数据中心的网络结构（L2 或者 L3），不需要额外的 NAT、隧道或者 Overlay Network，没有额外的封包解包，能够节约 CPU 运算，提高网络效率。</p>
<h3 id="5-Calico-和-flannel-CNI网络插件的区别"><a href="#5-Calico-和-flannel-CNI网络插件的区别" class="headerlink" title="5.Calico 和 flannel CNI网络插件的区别"></a>5.Calico 和 flannel CNI网络插件的区别</h3><ul>
<li>calico 根据iptables 规则进行路由转发， 并没有进行封包，解包的过程， 这和flannel比起来效率会快很多。</li>
<li>Fannel 实质上是一种 “覆盖网络”， 也就是将TCP数据包装在另一种网络包里面进行路由转发和通信， 目前已经支持UDP、VxLAN、AWS VPC和GCE路由等数据转发方式。默认的节点间数据通信方式就是UDP转发。</li>
</ul>
<h3 id="6-Kubernetes-CSI-模型"><a href="#6-Kubernetes-CSI-模型" class="headerlink" title="6.Kubernetes CSI 模型"></a>6.Kubernetes CSI 模型</h3><p>Kubernetes CSI 是Kubernetes 推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用 Kubernetes 的原生存储机制为容器提供存储服务。CSI 使得存储提供方的代码能和Kubernetes 代码彻底解耦，部署也与Kubernetes 核心组件分离，显然，存储插件的开发由提供方自行维护，就能为Kubernetes 用户提供更多的存储功能，也更加安全可靠。</p>
<h3 id="7-Kubernetes-数据持久化方式有哪些"><a href="#7-Kubernetes-数据持久化方式有哪些" class="headerlink" title="7.Kubernetes 数据持久化方式有哪些"></a>7.Kubernetes 数据持久化方式有哪些</h3><p>Kubernetes 通过数据持久化来持久化保存重要数据，常见的方式有：</p>
<ul>
<li>EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由 Pod 内保部映射到宿主机上。类似于docker 中的 manager volume。当Pod节点删除时，column的数据也会被删除。</li>
<li>Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于 docker 中的bind mount 挂载方式。</li>
<li>PersistentVolume（简称 PV）：如基于 NFS 服务的 PV，也可以基于 GFS 的PV。它的作用是统一数据持久化目录，方便管理。</li>
</ul>
<h3 id="8-简述-Kubernetes-PV-和PVC？"><a href="#8-简述-Kubernetes-PV-和PVC？" class="headerlink" title="8.简述 Kubernetes PV 和PVC？"></a>8.简述 Kubernetes PV 和PVC？</h3><p>答：PV 是对底层网络共享存储的抽象，将共享存储定义为一种“资源”。PVC 则是用户对存储资源的一个“申请”。</p>
<h3 id="9-K8s所支持的存储供应模式"><a href="#9-K8s所支持的存储供应模式" class="headerlink" title="9.K8s所支持的存储供应模式"></a>9.K8s所支持的存储供应模式</h3><p>Kubernetes 支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。</p>
<ul>
<li>静态模式：集群管理员手工创建许多 PV，在定义 PV 时需要将后端存储的特性进行设置。</li>
<li>动态模式：集群管理员无须手工创建 PV，而是通过 StorageClass 的设置对后端存储进行描述，标记为某种类型。此时要求 PVC 对存储的类型进行声明，系统将自动完成 PV 的创建及与 PVC 的绑定。</li>
</ul>

      
    </div>

    
      


    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/weixin.jpg" alt="刘小恺(Kyle) wechat" style="width: 200px; max-width: 100%;"/>
    <div>如有疑问可联系博主</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
               <div id="needsharebutton-postbottom">
                 <span class="btn">
                    <i class="fa fa-share-alt" aria-hidden="true"></i>
                 </span>
               </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/11/21/08.%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/2.1.Istio/" rel="next" title="istio">
                <i class="fa fa-chevron-left"></i> istio
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="刘小恺(Kyle)" />
            
              <p class="site-author-name" itemprop="name">刘小恺(Kyle)</p>
              <p class="site-description motion-element" itemprop="description">吃喝玩乐、好吃懒做、醉生梦死、不劳而获</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">326</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">86</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">93</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/KyleAdultHub" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:liukaijian45@163.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#kubenetes架构与运维"><span class="nav-text">kubenetes架构与运维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kubernetes-的组成"><span class="nav-text">1.kubernetes 的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-简述kubenetes-的基础概念"><span class="nav-text">2.简述kubenetes 的基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Worker-节点加入集群的过程"><span class="nav-text">3.Worker 节点加入集群的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-如何使用-EFK-统一管理k8s日志"><span class="nav-text">4.如何使用 EFK 统一管理k8s日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-K8s如何优雅的关机维护节点"><span class="nav-text">5.K8s如何优雅的关机维护节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubenetes-控制平面"><span class="nav-text">kubenetes 控制平面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-etcd-介绍和适应的场景"><span class="nav-text">1. etcd 介绍和适应的场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-etcd-store-的实现"><span class="nav-text">2.etcd store 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-K8s部署高可用的etcd经验"><span class="nav-text">3.K8s部署高可用的etcd经验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-apiserver介绍"><span class="nav-text">4.apiserver介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-apiserver认证"><span class="nav-text">5.apiserver认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-apiserver鉴权介绍"><span class="nav-text">6.apiserver鉴权介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Kubenetes-RBAC-vs-ABAC"><span class="nav-text">7.Kubenetes   RBAC vs ABAC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Kubernetes-的准入机制"><span class="nav-text">8.Kubernetes 的准入机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Kubernetes-如何保证集群的安全性"><span class="nav-text">9.Kubernetes 如何保证集群的安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-K8s各模块如何与-API-Server-通信"><span class="nav-text">10.K8s各模块如何与 API Server 通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Controller-Manager"><span class="nav-text">11.Controller Manager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Controller-的工作流程及原理"><span class="nav-text">12.Controller 的工作流程及原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Kubernetes-Scheduler作用及原理"><span class="nav-text">13.Kubernetes Scheduler作用及原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Scheduler-绑定Pod到-worker-流程"><span class="nav-text">14.Scheduler 绑定Pod到 worker 流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-Controller的协同工作原理"><span class="nav-text">15.Controller的协同工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes-常用对象"><span class="nav-text">Kubernetes 常用对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-简述-Kubernetes-RC-的机制"><span class="nav-text">1.简述 Kubernetes RC 的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ReplicationController和ReplicaSet区别"><span class="nav-text">2.ReplicationController和ReplicaSet区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Statefulset-与-Deployment-的差异"><span class="nav-text">3.Statefulset 与 Deployment 的差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Kubernetes-deployment-升级过程"><span class="nav-text">4.Kubernetes deployment 升级过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Kubernetes-deployment-升级策略"><span class="nav-text">5.Kubernetes deployment 升级策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Kubernetes-自动扩容机制？"><span class="nav-text">6.Kubernetes 自动扩容机制？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod生命周期和资源管理"><span class="nav-text">Pod生命周期和资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Pod-可能位于的状态？"><span class="nav-text">1. Pod 可能位于的状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Pod-的常见调度方式？"><span class="nav-text">2.Pod 的常见调度方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-创建一个Pod的主要流程？"><span class="nav-text">3.创建一个Pod的主要流程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Kubernetes中Pod的重启策略？"><span class="nav-text">4.Kubernetes中Pod的重启策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Pod-的健康检查方式？"><span class="nav-text">5.Pod 的健康检查方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Pod-的LivenessProbe-探针种类？"><span class="nav-text">6.Pod 的LivenessProbe 探针种类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-pod-中-readness-和liveness-的区别"><span class="nav-text">7.pod 中 readness 和liveness 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Pod-如何实现对节点的资源控制？"><span class="nav-text">8.Pod 如何实现对节点的资源控制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pod如何进行资源限制"><span class="nav-text">Pod如何进行资源限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Pod-Requests-Limits-对Pod调度影响"><span class="nav-text">9.Pod Requests\Limits 对Pod调度影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-QoS-模型"><span class="nav-text">10.QoS 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-kubernets-cpuset"><span class="nav-text">11.kubernets cpuset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-节点宕机后Pod的驱逐过程"><span class="nav-text">12.节点宕机后Pod的驱逐过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-pod-启动失败以及排查"><span class="nav-text">13.pod 启动失败以及排查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-init-容器的介绍和作用"><span class="nav-text">14.init 容器的介绍和作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-PodSecurityPolicy实现哪些安全策略"><span class="nav-text">15.PodSecurityPolicy实现哪些安全策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubernetes流量控制"><span class="nav-text">kubernetes流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Headless-Service的作用？"><span class="nav-text">1.Headless Service的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Kubernetes-Service-及类型？"><span class="nav-text">2.Kubernetes Service 及类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Service-分发后端的策略？"><span class="nav-text">3.Service 分发后端的策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-外部如何访问K8s集群内的服务？"><span class="nav-text">4.外部如何访问K8s集群内的服务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-kube-proxy-的作用"><span class="nav-text">5.kube-proxy 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-kube-proxy-的三种工作模式"><span class="nav-text">6.kube-proxy 的三种工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-kube-proxy-ipvs原理"><span class="nav-text">7.kube-proxy ipvs原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-kube-proxy-ipvs-和iptables-的异同"><span class="nav-text">8.kube-proxy ipvs 和iptables 的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-core-dns组件介绍"><span class="nav-text">9.core dns组件介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Kubernetes-ingress介绍？"><span class="nav-text">10.Kubernetes ingress介绍？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Service-Mesh-介绍"><span class="nav-text">11.Service Mesh 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-istio-架构"><span class="nav-text">12.istio 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-istio-原理"><span class="nav-text">13.istio 原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubelet"><span class="nav-text">kubelet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Kubernetes-kubelet-的作用"><span class="nav-text">1.Kubernetes kubelet 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-kubelet-如何监控Worker-节点资源"><span class="nav-text">2.kubelet 如何监控Worker 节点资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-简述-Kubernetes-CNI-模型"><span class="nav-text">3.简述 Kubernetes CNI 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Kubernetes-Calico-网络组件原理"><span class="nav-text">4.Kubernetes Calico 网络组件原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Calico-和-flannel-CNI网络插件的区别"><span class="nav-text">5.Calico 和 flannel CNI网络插件的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Kubernetes-CSI-模型"><span class="nav-text">6.Kubernetes CSI 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Kubernetes-数据持久化方式有哪些"><span class="nav-text">7.Kubernetes 数据持久化方式有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-简述-Kubernetes-PV-和PVC？"><span class="nav-text">8.简述 Kubernetes PV 和PVC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-K8s所支持的存储供应模式"><span class="nav-text">9.K8s所支持的存储供应模式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘小恺(Kyle)</span>

  

  
</div>


  










        








        
      </div>
    </footer>

    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'V62wzdGpgPV7y1tPnu1v1KYX-gzGzoHsz',
        appKey: 'SkJs3cwXAUsdgr6BkxmW2ctm',
        placeholder: '客观(*╹▽╹*)，请留下您的宝贵意见...   \n 请用浏览器打开进行评论, 在微信或其他客户端可能导致作者收不到提醒 \n 信息栏作用:\n 昵称: 在评论中显示的昵称 \n 邮箱: 可以在收到您评论的回复后通知到您邮箱 \n 网址: 评论需要跳转链接可填写, 将可以通过点击您评论中的昵称进行跳转 \n',
        avatar:'monsterid',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('100');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Wechat,Weibo,QQZone";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Wechat,Weibo,QQZone";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

  

  

  
</body>
</html>
